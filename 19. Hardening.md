Process of enhancing the security of a system, application, or network by implementing a series of measures and configurations that reduces its exposure to vulnerabilities and potential threats.
### Changing Default Configurations
Now, whenever you install a new piece of hardware or software, there are certain default configurations that they are going to utilize.
These defaults or factory settings are usually not configured with security in mind, but instead, they are configured to allow a new user to more quickly install and use the new piece of hardware or software.
Such as:
1. Default Passwords:
   Default passwords or credentials are present authentication details that are provided by manufactures for initial access to a device or piece of software.
   To improve security, default passwords must be changed immediately during system hardening. Leaving manufacturer-provided credentials in place makes devices extremely vulnerable, as attackers commonly scan for systems still using these defaults.

2. Disable any unneeded ports and protocols on the system:
   Disabling any unneeded ports and protocols is an important hardening step because open services create potential entry points for attackers. By shutting down unused ports and disabling unnecessary protocols, you reduce the system’s attack surface and limit the ways an attacker can communicate with or exploit the device. This ensures only essential services are exposed and running.

3. Check for any open ports on the devices:
   Systems often come with default services running that open unnecessary ports, which can expose the device to attacks. Regularly scanning and identifying open ports helps ensure that only required services are enabled, reducing the attack surface and strengthening overall security.
### Restricting Applications
Systems often include many default applications, and users frequently install additional software that they don’t actually need. Each unnecessary application increases the attack surface by introducing new vulnerabilities, services, or permissions that an attacker could exploit. Restricting, removing, or blocking the installation of unused or unapproved applications helps reduce potential entry points, making the system more secure and easier to manage.
##### Least Functionality
A process of configuring a workstation or server with only essential applications and services for the user.
##### Secure Baseline Image
A standardized workstation setup, including OS, essential applications, and strict policies in corporate networks.
##### Allow-listing
A security measure that permits only approved applications to run on an operating system.
##### Block-listing
Entails preventing listed applications from running, allowing all others to execute.

```
Allowlisting: More secure but more complex to manage
Blocklisting: Easier to manage but less secure
```
### Unnecessary Services
Services: Background applications that operate within the OS, executing a range of tasks.

Operating systems often run background services that are not required for normal operations, either enabled by default or leftover from installed applications. These unused services can expose additional ports, consume resources, and create openings that attackers may exploit. Disabling or removing unnecessary services reduces the system’s attack surface and strengthens overall security by ensuring only essential functions are active.
### Trusted Operating Systems
Designed to provide a secure computing environment by enforcing stringent security policies that usually rely on mandatory access controls.
##### EAL (Evaluation Assurance Level) 
Evaluation Assurance Level or EAL is part of the Common Criteria (CC) security certification used to measure how thoroughly an operating system or product has been tested and evaluated.
EAL4 or EAL4+, is the standard level for trusted, commercially deployed operating systems.

Features of Trusted Operating Systems:
- Mandatory Access Control (MAC):
  Access permissions are determined by a policy defined by the system administrators and enforced by the operating system.
- Security Auditing:
  Trusted operating systems generate detailed audit logs of all security-relevant events, such as logins, file access, policy changes, and administrative actions. These logs help detect suspicious behavior, reconstruct incidents, and ensure compliance with security policies.
- Role-based Access Control:
  RBAC assigns permissions based on user roles rather than individual accounts. Each role has predefined privileges, ensuring users only have access necessary for their job, reducing the risk of unauthorized actions or privilege misuse.
### Updates and Patches
Updates and patches are essential for keeping systems secure by fixing vulnerabilities, improving stability, and enhancing performance. Applying them promptly reduces the risk of exploitation, as attackers often target known weaknesses that remain unpatched in systems.
##### Hotfixes
A hotfix is a small, targeted patch released quickly to fix a specific critical bug or security vulnerability. It is applied immediately and usually doesn't wait for scheduled update cycles.
##### Updates
Updates include incremental improvements such as bug fixes, minor security patches, and feature enhancements. They are released regularly and help keep the system functioning smoothly and securely.
##### Service Packs
Service Packs are large, cumulative packages that bundle multiple updates, patches, and hotfixes into a single installation. They ensure systems are up-to-date and stable, reducing the need to install individual patches one by one.

Effective patch management program:
1. Assign a dedicated team to regularly manage security patches
2. Establish automated system-wide patching for OS and applications
3. Include cloud resources in the patch management program
4. Categorize patches as urgent, important, or non-critical for prioritization
5. Create a test environment to verify critical patches before production deployment
6. Maintain comprehensive patch logs for evaluation and monitoring
7. Establish a process for evaluating, testing, and deploying firmware updates
8. Deploy a technical process for pushing approved urgent patches to production
9. Periodically assess non-critical patches for combined rollout
### Patch Management
Planning, testing, implementing, and auditing of software patches.
Patch Management Process
1. Planning:
   Planning involves creating policies, procedures, and tools to identify, track, and evaluate patches. It also includes verifying patch compatibility with existing systems, applications, hardware, and business requirements to ensure smooth deployment.
2. Testing:
   Before deployment, patches are tested in a controlled environment to ensure they don’t break system functionality, disrupt applications, or create new vulnerabilities. This step helps validate stability and reduces the risk of downtime in production.
3. Implementation:
   Patches are deployed to live systems using a phased rollout to minimize risk.
   Ring Method: Deployment begins with a small group (e.g., 10–10 systems in Ring 1), then expands to a larger group (e.g., 50–100 systems in Ring 2), and finally to all remaining systems. This staged rollout helps catch issues early before full deployment.
4. Auditing:
   After patching, systems are audited to verify successful installation, ensure compliance with security policies, and confirm no systems were missed. Audit logs also help track failures and identify systems needing reconfiguration.

Patch Management Tools Example:
Microsoft Endpoint Configuration Manager (MECM) is a widely used enterprise tool for automating patch distribution, tracking compliance, and managing updates across large environments.

Firmware Updates:
Firmware patching is crucial because network devices like routers, switches, and firewalls rely on firmware for secure operation.

Cisco UCS Manager provides centralized management and firmware updates for servers and network infrastructure, ensuring hardware components run the latest and most secure versions to protect against vulnerabilities.
### Group Policies
Set of rules or policies that can be applied to a set of users or computer accounts within an operating system.
Group Polices are also used to create a secure baseline as part of the large configuration management program.
##### Baselining
Process of measuring changes in the network, hardware, or software environment.
### SELinux
SELinux is a security framework built into Linux systems, mainly used in CentOS and Red Hat Enterprise Linux (RHEL), to provide strong access controls based on Mandatory Access Control (MAC). Unlike traditional Linux security, which relies mostly on user permissions, SELinux enforces strict policies that limit what every process, file, and user can do - greatly reducing the impact of compromised applications or malware.
##### Mandatory Access Control (MAC)
Under MAC, the operating system-not the user - enforces access rules. This means even a root user or a compromised process cannot bypass SELinux policies. Access is determined by predefined rules that specify exactly what actions are allowed.
##### Context-Based Permissions
Linux security frameworks like SELinux and AppArmor use context labels to control access.
- SELinux uses security contexts (User, Role, Type, Level) to decide if a process can interact with a file.
- AppArmor uses file-system–based profiles to limit what processes can access.
##### Discretionary Access Control (DAC)
Traditional Linux uses DAC, where file owners control access using permissions like rwx, owners, and groups.
SELinux works on top of DAC, so even if DAC allows access, SELinux can still deny it based on MAC rules.
##### SELinux Security Contexts
Every file, process, and resource in SELinux has a context label made up of three main parts (and an optional fourth):
1. User Context: Defines the SELinux user identity.
   Examples:
   unconfined_u – normal unrestricted user
   user_u – regular unprivileged SELinux users
   sysadm_u – system administrators
   root – root user mapped to a specific SELinux user
2. Role: Defines what a user can do
   object_r – the role applied to files and directories (most common)
3. Type: Group objects together that have similar security requirements or characteristics
4. Level: Used to describe the sensitivity level; of a given file, directory, or process
##### SELinux Modes
SELinux operates in three modes:
1. Disabled: SELinux is completely turned off. No security enforcement.
2. Enforcing (Recommended): SELinux actively checks and blocks unauthorized actions.
3. Permissive: SELinux logs violations but does not block them, used for debugging and testing policies.
##### SELinux Policy Types
SELinux uses different policy styles to control systems:
1. Targeted Policy (Default in RHEL/CentOS):
   - Only specific, high-risk services (like Apache, SSH, DNS) are protected with MAC rules
   - Normal users and processes run in unconfined_t
   - Easier to manage.
2. Strict Policy:
   - All processes and users are confined by SELinux rules
   - Very secure but harder to configure

Now, once SELinux is enforced on a system, there is going to be violation messages that are going to be captured as part of an audit log for you to be able to see what things people are doing that are not inside policies that you are not allowing.

SELinux is only as strong as the restricted profiles being created.
### Data Encryption Levels
Process of converting data into a secret code to prevent unauthorized access.
1. Full Disk Encryption (FDE):
   Full Disk Encryption encrypts the entire drive, including the operating system, system files, applications, and user data. Nothing on the disk can be read without the correct key or authentication.
   Example:
   A laptop used by a company employee has BitLocker enabled.
   If the laptop gets stolen, the thief cannot boot into Windows or read any files because the entire disk is encrypted. Without the BitLocker recovery key, the data is inaccessible.
   
2. Partition Encryption:
   Partition encryption protects only a specific partition of a disk. This is useful when a user wants to separate encrypted and non-encrypted storage areas.
   Example:
   A system has: C: for OS and D: for personal data
   The user encrypts only the D: drive using tools like LUKS or VeraCrypt.
   If someone accesses the PC, they can boot the OS from C:, but they cannot open the encrypted D: partition without the key.

3. File Encryption:
   File encryption protects individual files or folders. It is useful when you want to secure only specific sensitive files.
   Example:
   A user encrypts sensitive PDF files containing customer details using GnuPG or 7-Zip AES-256 encryption.
   Even if the system is compromised, encrypted files remain secure unless the password is known.

4. Volume Encryption:
   Volume encryption encrypts an entire logical volume—which might include multiple partitions or span across disks.
   Example:
   Using VeraCrypt, a user creates a virtual encrypted volume named SecureDrive.
   This volume mounts like a USB drive. Everything stored inside (documents, images, logs) is automatically encrypted, but the rest of the system is not.

5. Database Encryption:
   Database encryption protects entire databases or selected fields within them to secure sensitive stored information.
   Example:
   A company stores customer records in MySQL.
   They enable Transparent Data Encryption (TDE), so: the entire database file on the disk is encrypted.

6. Record Encryption:
   Record-level encryption encrypts individual rows or records inside a database table.
   This gives fine-grained protection for highly sensitive data.
   Example:
   A healthcare system stores patient records in a SQL database.
   For each patient row, the field containing medical diagnosis or prescription details is encrypted using a separate key per record.
### Secure Baselines
Standard security configuration applied to guarantee minimum security for a system, network, or application.
1. establish a secure baseline:
   Establishing a secure baseline involves defining the minimum security configuration that every system, network device, and application must meet. This includes settings like password policies, firewall rules, OS hardening, patch levels, logging requirements, and access controls. Organizations typically use industry standards such as CIS Benchmarks, NIST guidelines, or DISA STIGs to build a baseline that ensures consistent and reliable protection across all assets.

2. deploy secure baseline across all the organization's digital assets:
   After creating the baseline, it must be deployed consistently across the organization’s digital assets, including servers, endpoints, network devices, and cloud workloads. Deployment is usually automated through tools like Microsoft Intune, SCCM, Ansible, or Group Policy to ensure uniform configuration without human error. Applying the baseline everywhere reduces security gaps and ensures that all systems meet the organization’s minimum protection requirements.
   
3. maintain the secure baseline on all assets:
   Maintaining the secure baseline means continuously monitoring systems for configuration drift and ensuring all assets remain aligned with the defined baseline. This includes updating the baseline when new threats or vulnerabilities arise, regularly auditing configurations, and automatically correcting deviations through configuration management tools. Keeping the baseline maintained ensures ongoing compliance, reduces risks, and preserves a strong security posture over time.

Next module [[20. Security Techniques]]

